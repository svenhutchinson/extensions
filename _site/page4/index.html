<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Hyde &middot; A Jekyll theme, with instant search
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/algoliasearch-jekyll-hyde/public/css/poole.css">
  <link rel="stylesheet" href="/algoliasearch-jekyll-hyde/public/css/syntax.css">
  <link rel="stylesheet" href="/algoliasearch-jekyll-hyde/public/css/hyde.css">
  <link rel="stylesheet" href="/algoliasearch-jekyll-hyde/public/css/algolia.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/algoliasearch-jekyll-hyde/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/algoliasearch-jekyll-hyde/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-09">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/algoliasearch-jekyll-hyde/">
          Hyde
        </a>
      </h1>
      <p class="lead">The popular <a href="http://hyde.getpoole.com/" target="_blank">Hyde theme</a> for <a href="http://jekyllrb.com" target="_blank">Jekyll</a>, now with instant-search capabilities. Made by <a href="https://twitter.com/mdo" target="_blank">@mdo</a> and <a href="https://www.algolia.com/" target="_blank">Algolia</a></p>
    </div>

    <input type="text" class="algolia__input js-algolia__input" autocomplete="off" name="query" placeholder="Search in this site..." />

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/algoliasearch-jekyll-hyde/">Home</a>

      

      
      
        
          
        
      
        
          
          <a class="sidebar-nav-item" href="/algoliasearch-jekyll-hyde/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="https://github.com/algolia/algoliasearch-jekyll-hyde">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.1.0</span>
    </nav>

    <p>&copy; 2016. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="algolia__initial-content js-algolia__initial-content"><div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/08/28/concertwith-mes-competitive-edge-revamped-search-ux-algolia/">
        Concertwith.me's Competitive Edge: A Revamped Search UX with Algolia
      </a>
    </h1>

    <span class="post-date">28 Aug 2014</span>

    <p>There are a lot of music discovery apps on the market, yet sifting through
concert listings is anything but seamless. That’s why Cyprus-based startup
<a href="http://concertwith.me/">Concertwith.me</a> aims to make finding local concerts
and festivals as intuitive as possible. Automatically showing upcoming events
in your area, the site offers personalized recommendations based on your
preferences and your Facebook friends’ favorited music. Covering over 220,000
events globally, the site uses Algolia to offer meaningful results for
visitors who are also looking for something different.</p>

<p>Founder Vit Myshlaev admits that concert sites often share the same pool of
information. The differentiator is how that information is presented. “The
biggest advantage one can have is user experience,” he explains. “There’s
information out there, but do users find it? The reason that people don’t go
to cool concerts is that they still don’t know about them!”</p>

<p>As an example, he showed me one of the largest live music discovery sites on
the web. Searching for an artist required navigating a convoluted maze of
links before pulling up irrelevant results. “Users have to type in queries
without autocomplete, typo-tolerance, or internationalization. They have to
scroll through a long list of answers and click on paginated links. That’s not
what people want in 2014,” said Myshlaev.</p>

<p>To simplify search and make the results more relevant, Concertwith.me used our
API. “We got a lot of user feedback for natural search,” Myshlaev wrote. Now
visitors can search for artists and concerts instantly. With large user bases
in the United States, Germany, France, Spain, Italy, Russia and Poland,
Concertwith.me also benefits from Algolia’s <a href="https://www.algolia.com/doc#Multilingual">multi-lingual search
feature</a>. “We’ve localized our app
to many countries. For example, you can search in Russian or for artists that
are Russian, and results will still come up,” says Myshlaev.</p>

<p><a href="https://blog.algolia.com/wp-
content/uploads/2014/08/search.gif"><img src="/algoliasearch-jekyll-hyde/assets/search.gif" alt="search" /></a></p>

<p>For users with a less targeted idea of what they’re looking for,
Concertwith.me implemented structured search via
<a href="http://faq.algolia.com/basics/what-is-faceting/">faceting</a>. “We also realized
that some visitors don’t know what they want. Algolia search helps them find
answers to questions like, Where will my favorite artist perform? How much do
tickets cost? Are there any upcoming shows?”</p>

<p><a href="https://blog.algolia.com/wp-
content/uploads/2014/08/recommendations.gif"><img src="/algoliasearch-jekyll-hyde/assets/recommendations.gif" alt="recommendations" /></a></p>

<p>Concertwith.me’s goal is to reduce informational noise so that users can find
and discover music as soon as possible. The start up experimented with a
number of other search technologies before reading an <a href="http://insideintercom.io/7-things-wish-every-search-did/">article about us on
Intercom.io</a>, which
inspired Myshlaev. “When I saw what Algolia could do, I knew that this was the
competitive edge I was looking for.”</p>

<p><strong><em>Want to build a search bar with multi-category auto-completion like Concertwith.me? <a href="https://www.algolia.com/doc/tutorials">Learn how through our tutorial</a>.</em></strong></p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/08/21/algolia-for-realtime-expense-reporting/">
        How Abacus Leverages Algolia for Realtime Expense Reporting
      </a>
    </h1>

    <span class="post-date">21 Aug 2014</span>

    <p>When one thinks of expense reporting, speed is far from the first descriptor
that comes to mind. Companies spend a substantial amount of time tracking
expenses, while employees linger in paperwork purgatory, wondering when they
will be reimbursed for their work-related charges. That’s why Abacus has made
it their mission to simplify expense management so that it occurs in real
time. Their creative implementation of Algolia helps make it happen.</p>

<p>Abacus is a mobile and desktop application that allows small businesses to
track and verify expenses on the go. Employees can upload a photo of their
receipt on the mobile app, and Abacus takes care of the rest. “For each
expense, we have a lot of data. We have the person who expensed it, the amount
of the expense, the time, and where it took place. We also have a lot of
metadata. For example, if you went out to breakfast, we pull in the name of
the restaurant, the address, the URL of the merchant. There’s tags and
categories and so on,” explains Ted Power, Co-Founder of Abacus. “And we
wanted to make all of that searchable.”</p>

<p><a href="https://blog.algolia.com/wp-
content/uploads/2014/08/Screen-Shot-2014-08-14-at-16.37.25.png"><img src="/algoliasearch-jekyll-hyde/assets/Screen-Shot-2014-08-14-at-16.37.25.png" alt="Abacus Algolia" /></a></p>

<p>To make all of that data accessible and interpretable for a financial manager,
Abacus turned to our API. “Algolia made it super easy for us to get faceted,
advanced search options. If you are the finance person at your company, you
can basically say ‘Show me all of the expenses over $50,’ or ‘Show me all the
expenses that don’t have a receipt.’ You can look at expenses for one person
or one category, like travel. You can even pivot off of 8 of these different
things. Algolia makes it super easy to do,” says Power. This accelerates the
process of expense verification and approval. “It’s good search. We have tags
like ‘car rental’ on auto-complete, for example. That’s all Algolia.”</p>

<p>Power adds that a “great implementation experience” was especially beneficial
for the start up. “It’s the kind of thing that would have taken ages to build
from scratch.” Co-Founder Joshua Halickman chimed in: “Being able to get up
and off the ground really quickly was great. In general, I love the speed.
Crazy fast. Really nice.”</p>

<p><a href="https://blog.algolia.com/wp-
content/uploads/2014/08/Screen-Shot-2014-08-14-at-16.38.34.png"><img src="/algoliasearch-jekyll-hyde/assets/Screen-Shot-2014-08-14-at-16.38.34.png" alt="Abacus Algolia" /></a></p>

<p>_Images courtesy of Abacus. Learn more _<a href="https://www.abacus.com"><em>on their
website.</em></a></p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/07/11/deploying-algolia-search-2-million-products/">
        Deploying Algolia to Search on more than 2 Million Products
      </a>
    </h1>

    <span class="post-date">11 Jul 2014</span>

    <p>The following post is an interview of <a href="fr.linkedin.com/pub/vincent-paulin/71/1a3/86a">Vincent Paulin</a>, R&amp;D Manager at <a href="http://www.alittlemarket.com/">A Little
Market</a> (recently acquired by Etsy).</p>

<p>As a fast growing ecommerce site for handmade goods in France, A Little Market
has seen its marketplace grow from a few thousand to over 2 million products
in just 5 years. With 90,000 designers and artisans using A Little Market
marketplace to buy, sell and collaborate, search quickly became a major part
of their ecommerce strategy and user experience.</p>

<h4 id="alittlemarket3"><strong><img src="/algoliasearch-jekyll-hyde/assets/Capture-decran-2014-07-11-17.31.04-1024x486.png" alt="ALittleMarket" /></strong></h4>

<h4 id="what-did-you-have-in-place-as-a-search-solution"><strong>What did you have in place as a search solution?</strong></h4>

<p>“We implemented a Solr based search 5 years ago and had been trying to tweak
it to fit our growing needs.  We had selected this system for its flexibility,
however, over time, that flexibility translated into constant maintenance,
modifications and lower relevance in our search results.</p>

<p>Then we investigated Elasticsearch. It is complex, yet powerful. As I was
diving deeper into Elasticsearch I realized that I could quickly gain an “ok”
search experience; however, a powerful search experience would mean investing
more time than we had to configure it. Then I did a little math:  learning the
platform would take a few weeks, configuring servers - a few days, and
configuring and tuning semantic search perfectly - several months.</p>

<p>Then we found Algolia.  We only had 3 months and knew Algolia would be much
easier to implement, so we A/B tested everything to see how it would impact
the search experience.</p>

<h4 id="can-you-tell-us-more-about-your-integration-process"><strong>Can you tell us more about your integration process?</strong></h4>

<p>The first thing we wanted to get done was to reference all the shops and our
best searches to make an autosuggest widget. Building this autosuggest with a
basic configuration took us 2 days.</p>

<p>Then we built an automatic task to aggregate shops and best searches every day
and configure Algolia indices. We also took on the task to create the front
javascript plugin. With the Algolia documentation and the examples on Github
it took us less than 1 hour.</p>

<p>The results of this first test were very encouraging.  With around 500k
requests per day, the response time was about 4 milliseconds on average and we
saw the conversion rate multiplied by 3 compared to the previous conversion
rate with a search bar with “no suggest”. For A Little Mercerie, another
marketplace we manage, the improvement was about 4 times greater.</p>

<p>After this first test, we were ready to fully commit to Algolia for our whole
search experience. The first step was to create a script to index our entire
product database in Algolia. This was easy to do with batch insert in Algolia
indices. We selected some attributes of our products such as the title,
categories, materials and colors to be indexed. That was a first try. We
wanted it to be quick and simple.</p>

<p>With the help of the open source demo code we developed a full JS sandbox
which can display paginated results with faceting to show the progress to the
team.  In less than a week, we had a fully working sandbox and the results
were promising.  Our query time averaged less than 20 milliseconds on 2
millions records.  With confidence we started to upgrade the algorithm on
Algolia, test it, again and again, adding some attributes to index such as
specific events (christmas, valentine’s day), custom tags, etc.</p>

<p>In addition, we implemented sorted results. They are really relevant with the
new numeric ranking option in settings. At that step we were able to sort
results by price, date, etc. You must create a specific index for each
specific ranking you need.  We also created a different index for each
language (French and Italian) and took this opportunity to do the same across
our  other websites, alittlemercerie.com and alittleepicerie.com.</p>

<p>To do this we created a custom API which abstracts the use of any kind of
search engine for all API clients. We end up losing the real-time search but
we need that for now in order to abstract everything and to collect data
before sending the results.</p>

<p>The next step was to erase the “no results” pages. For that, we were
progressively adding the last words of the query as optional words until we
had somes results.We never set as optional all the user queries.  We set at
least the first word or the first two words.</p>

<p>When search was ready, we still had plenty of time left to implement it on our
clients’ applications. We took more time than was needed to implement Algolia.
The speed of iteration with the Algolia API enables us to test everything in a
much shorter timeframe.</p>

<h4 id="how-has-algolias-api-helped-search-on-a-little-market"><strong>How has Algolia’s API helped search on A Little Market?</strong></h4>

<p>We are now able to answer more than 500/1000 requests per minute and we add
6000 new products every day to the search engine while over 3000 are removed,
in real time.</p>

<p>After this integration of the Algolia API, we saw an increase in our
conversion rate on search by 10%. This represents tens thousands of euros in
turnover per month for us. In a few weeks of work with one engineer, we had
replaced our main search engine for a better solution thanks to Algolia.”</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/07/09/keeping-data-in-your-search-engine-up-to-date/">
        Keeping Data in your Search Engine Up-to-Date
      </a>
    </h1>

    <span class="post-date">09 Jul 2014</span>

    <p>When we developed the first version of Algolia Search, we put a lot of effort
into developing a data update API. It worked like this: You could send us a
modified version of your data as soon as the change appeared, even if it
concerned only a specific part of a record. For example, this batch of
information could be the updated price or number of reviews, and we would only
update this specific attribute in your index.</p>

<p>However, this initial plan did not take into account that most of our big
customers would not benefit from this API due to their existing
infrastructure. If you had not planned to catch all updates in your
architecture, or if you were not using a framework like Ruby on Rails, it
could be very difficult to even have a notification for any of these updates.
The solution in this case was to use a batch update on a regular basis. It was
a good method to use if you didn’t want to change a single line of code in
your existing infrastructure, but the batch update was far from a cure-all.</p>

<h2 id="the-problem-of-batch-update">The problem of batch update</h2>

<p>There are two main ways to perform a batch update on a regular basis:</p>

<ol>
  <li>Scan your database and update all objects. This method is good if you have no delete operation, but if some data are removed from your database, you will need to perform an extra check to handle delete, which can be very slow.</li>
  <li>Clear the content of the index and import all your objects. With this method, you ensure that your index is well synchronized with your database. However, if you receive queries during the import, you will return partial results.  If interrupted, the whole rescan could break your relevance or your service.</li>
</ol>

<p>So the two approaches are somewhat buggy and dangerous.</p>

<h2 id="another-approach-build-a-new-index-with-another-name">Another approach: build a new index with another name</h2>

<p>Since our API allows the creation of a new index with a different name, you
could have made your batch import in a new index. Afterward, you would just
need to update your front end to send queries to this new index.</p>

<p>Since all indexing jobs are done asynchronously, we first need to check that
an indexing job is finished. In order to do that, we return an integer (called
TaskID) that allows you to check if an update job is applied. Thus, you just
have to use the API to check that the job is indexed.</p>

<p>But then a problem arises with mobile applications: You cannot change the
index name of an application as easily, since most of the time, it is a
constant in the application code. And even for a website, it means that the
batch will need to inform your frontend that the index name is different. This
can be complex.</p>

<h2 id="the-elegant-solution-move-operation">The elegant solution: move operation</h2>

<p>To solve these problems, we implemented a command that is well known on file
systems: <strong>move</strong>. You can move your new index on the old one, and this will
atomically update the content of the old index with the content of the new
one. With this new approach, you can solve all the previous update problems
with one simple procedure. Here’s how you would update an index called
“MyIndex”:</p>

<ol>
  <li>Initialize an index “MyIndex.tmp”</li>
  <li>Scan your database and import all your data in “MyIndex.tmp”</li>
  <li>Move “MyIndex.tmp in “MyIndex”</li>
</ol>

<p>You don’t have to do any modification on your backend to catch modifications,
nor do you need to change the index name on the frontend. Even better, you
don’t need to check the indexing status with our TaskID system since the
“move” operation will simply be queued after all “adds”. All queries will go
to the new index when it is ready.</p>

<h2 id="the-beauty-of-the-move-command">The beauty of the move command</h2>

<p>This command is so elegant that even customers who had been sending us
realtime updates via our updates API have decided to use this batch update on
a regular basis. The move command is a good way to ensure that there are no
bugs in your update code, nor divergence between your database and Algolia.</p>

<p>This operation is supported in our twelve API Clients. We go even further in
our Ruby on Rails integration: You need only use the ’reindex’ command
(introduced in 1.10.5) to automatically build a new temporary index and move
it on top of the existing one.</p>

<p>The move command is an example of how we try to simplify the life of
developers. If you see any other way we can help you, let us know and we’ll do
our best to remove your pain!</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/06/05/popular-misperceptions-search-service/">
        Common Misperceptions about Search as a Service
      </a>
    </h1>

    <span class="post-date">05 Jun 2014</span>

    <p>Since the first SaaS IPO by <a href="http://www.salesforce.com/">salesforce.com</a>, the
SaaS (Software as a Service) model has boomed in the last decade to become a
global market that is worth billions today. It has taken a long way and a lot
of evangelisation to get there.</p>

<p>Before <a href="http://www.salesforce.com/">salesforce.com</a> and the other SaaS
pioneers succeeded at making SaaS a standard model, the IT departments were
clear: the infrastructure as well as the whole stack had to be behind their
walls. Since then, mindsets have shifted with the cloud revolution, and you
can now find several softwares such as Box, Jive or Workday used by a lot of
Fortune 500 companies and millions of SMBs and startups.</p>

<p>Everything is now going SaaS, even core product components such as internal
search. This new generation of SaaS products is facing the same misperceptions
their peers faced years ago. So today, we wanted to dig into the
misperceptions about search as a service in general.</p>

<h2 id="hosting-your-search-is-way-more-complex-and-expensive-than-you-may-think">Hosting your search is way more complex and expensive than you may think</h2>

<p>Some people prefer to go on-premises as they only pay for the raw resource,
especially if they choose to run open source software on it. By doing this,
they believe they can skip the margin layer in the price of the SaaS
solutions. The problem is that this view highly under-estimates the Total Cost
of Ownership (TCO) of the final solution.</p>

<p>Here are some reasons why hosting your own search engine can get extremely
complex &amp; expensive:</p>

<h3 id="hardware-selection">Hardware selection</h3>

<p>A search engine has the particularity of being very IO (indexing), RAM
(search) and CPU (indexing + search) intensive. If you want to host it
yourself, you need to make sure your hardware is well sized for the kind of
search you will be handling. We often see companies that run on under-sized
EC2 instances to host their search engine are simply unable to add more
resource-consuming features (faceting, spellchecking, auto-completion).
Selecting the right instance is more difficult than it seems, and you’ll need
to review your copy if your dataset, feature list or queries per second (QPS)
change. Elasticity is not only about adding more servers, but is also about
being able to add end-users features. Each Algolia cluster is backed by 3
high-end bare metal servers with at least the following hardware
configuration:</p>

<ul>
  <li><strong>CPU</strong>: Intel Xeon (E5-1650v2) 6c/12t 3,5 GHz+/3,9 GHz+</li>
  <li><strong>RAM</strong>: 128GB DDR3 ECC 1600MHz</li>
  <li><strong>Disk</strong>:  1.2TB  SSD (via 3 or 4 high-durability SSD disks in RAID-0)</li>
</ul>

<p>This configuration is key to provide instant and realtime search, answering
queries in &lt;10ms.</p>

<h3 id="server-configuration">Server configuration</h3>

<p>It is a general perception of many technical people that server configuration
is easy: after all it should just be a matter of selecting the right EC2
Amazon Machine Image (AMI) + a puppet/chef configuration, right?
Unfortunately, this isn’t the case for a search engine. Nearly all AMIs
contain standard kernel settings that are okay if you have low traffic, but a
<strong>nightmare</strong> as soon as your traffic gets heavier. We’ve been working with
search engines for the last 10 years, and we still discover kernel/hardware
corner cases every month! To give you a taste of some heavyweight issues
you’ll encounter, check out the following bullet points:</p>

<ul>
  <li><strong>IO</strong>: Default kernel settings are <strong>NOT</strong> optimized for SSDs!!! For example, Linux’s I/O scheduler is configured to merge some I/Os to reduce the hard-drive latency while seeking the disk sectors: non-sense on SSD and slowing the overall server performance.</li>
  <li><strong>Memory</strong>: The kernel caches a lot, and that’s cool… most of the time. When you write data on the disk, it will actually be written in the RAM and flushed to disk later by the pdflush process. There are some advanced kernel parameters that allow configuration. vm.dirty_background_ratio is one of them: it configures the maximum percentage of memory that can be “dirty” (in cache) before it is written on the disk.  In other words, if you have 128GB of RAM, and you are using the default value of 10% for dirty_background_ratio, the system will only flush the cache when it reaches 12GB!!!! Flushing such bursts of writes will <strong>slow down your entire system</strong> (even on SSD), killing the speed of all searches &amp; reads. <a href="http://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/">Read more</a>.</li>
  <li><strong>Network</strong>:  When calling the listen function in BSD and POSIX sockets, an argument called the backlog is accepted. The backlog argument defines the maximum length of the queue of pending connections for sockfd. If the backlog argument is higher than the value in net.core.somaxconn, it is silently truncated to that value. The default value is 128 which is <strong>way too low</strong>! If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED. <a href="http://engineering.chartbeat.com/2014/01/02/part-1-lessons-learned-tuning-tcp-and-nginx-in-ec2/">Read more</a> &amp; <a href="https://www.youtube.com/watch?v=yL4Q7D4ynxU">even more</a>.</li>
</ul>

<p>We’ve been working hard to fine-tune such settings and it has allowed us to
handle today several thousands of search operations per second on one server.</p>

<h3 id="deployment--upgrades-are-complex">Deployment &amp; upgrades are complex</h3>

<p>Upgrading software is one of the main reasons of service outages. It should be
fully automated and capable of rolling back in case of a deployment failure.
If you want to have a safe deployment, you would also need a pre-production
setup that duplicates your production’s setup to validate a new deployment, as
well as an A/B test with a part of your traffic. Obviously, such setup
requires additional servers. At Algolia, we have test and pre-production
servers allowing us to validate every deployment before upgrading your
production cluster. Each time a feature is added or a bug is fixed on the
engine, all of our clusters are updated so that everyone benefits from the
upgrade.</p>

<h3 id="toolbox-vs-features">Toolbox vs features</h3>

<p>On-premises solutions were not built to be exposed as a public service: you
always need to build extra layers on top of it. And even if these solutions
have plenty of APIs and low-level features, turning them into end-user
features requires time, resources and a lot of engineering (more than just a
full-stack developer!). You may need to re-develop:</p>

<ul>
  <li><strong>**Auto-completion</strong>:** to suggest best products/queries directly from the search bar while handling security &amp; business filters (not only suggesting popular entries);</li>
  <li><strong>Instant-Faceting:</strong> to provide realtime faceting refreshed at each keystroke;</li>
  <li><strong>**Multi-datacenter replication</strong>:** synchronize your data across multiple instances and route the queries to the right datacenter to ensure the best search performance all around the world;</li>
  <li><strong>Queries analytics</strong>: to get valuable information on what and how people search;</li>
  <li><strong>Monitoring</strong>: To track in realtime the state of your servers, the storage you use, the available memory, the performance of your service, etc.</li>
</ul>

<h2 id="on-premises-is-not-as-secure-as-one-might-think">On-premises is not as secure as one might think</h2>

<p>Securing a search engine is very complex and if you chose to do it yourself,
you will face three main challenges:</p>

<ol>
  <li> <strong>Controlling who can access your data</strong>: You probably have a model that requires permissions associated with your content. Search as a service providers offer packaged features to handle user based restrictions. For example you can generate an API Key that can only target specific indexes. Most on-premise search engines do not provide any access control feature.</li>
  <li><strong>Protecting yourself against attacks</strong>: There are various attacks that your service can suffer from (denial of service, buffer overflow, access control weakness, code injection, etc.). API SaaS providers put a lot of effort into having the best possible security. For example API providers reacted the most quickly to the “HeartBleed” SSL vulnerability; It only took a few hours after disclosure for <a href="https://www.twilio.com/blog/2014/04/customer-security-notice-on-cve-2014-0160-heartbleed-disclosure.html">Twilio</a>, <a href="https://www.firebase.com/blog/2014-04-08-open-ssl-security-update.html">Firebase</a> and <a href="http://blog.algolia.com/dealing-openssl-security-issue/">Algolia</a> to fix the issue.</li>
  <li><strong>Protecting yourself from unwarranted downloads:</strong> The search feature of your website can easily expose a way to grab all your data. Search as a service providers offer packaged features to help prevent this problem (rate limit, time-limited API Key, user-restricted API Key, etc.).</li>
</ol>

<p>Mastering these three areas is difficult, and API providers are challenged
every day by their customers to provide a state-of-the-art level of security
in all of them. Reaching the same level of security with an on-premise
solution would simply require too much investment.</p>

<h2 id="search-as-a-service-is-not-reserved-to-simple-use-cases">Search as a service is not reserved to simple use cases</h2>

<p>People tend to believe that search as a service is only good for basic use
cases, which prevents developers from implementing fully featured search
experiences. The fact of the matter is that search as a service simply handles
all of the heavy lifting while keeping the flexibility to easily configure the
engine. Therefore it enables any developers, even front-end only developers,
to build complex instant search implementation with filters, faceting or geo-
search. For instance, feel free to take a look at
<a href="http://jadopado.com">JadoPado</a>, a customer who developed a fully featured
instant search for their e-commerce store. Because your solution runs inside
your walls once in production,  you will need a dedicated team to constantly
track and fix the multiple issues you will encounter. Who would think of
having a team dedicated to ensuring their CRM software works fine? It makes no
sense if you use a SaaS software like most people do today. Why should it make
more sense for components such as search? All the heavy lifting and the
operational costs are now concentrated in the SaaS providers’ hands, making it
eventually way more cost-efficient for you..</p>


  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/algoliasearch-jekyll-hyde/page5">Older</a>
  
  
    
      <a class="pagination-item newer" href="/algoliasearch-jekyll-hyde/page3">Newer</a>
    
  
</div>
</div>

      <div class="algolia__search-content js-algolia__search-content">
        <h1 class="page-title">Search</h1>
        <div class="posts algolia__results"></div>
      </div>
    </div>

  <script>
  window.ALGOLIA_CONFIG = {
    'applicationId': 'latency',
    'indexName': 'jekyll',
    'apiKey': '6be0576ff61c053d5f9a3225e2a90f76',
    'baseurl': '/algoliasearch-jekyll-hyde'
  }
</script>
<script id="algolia__template" type="text/template">

  <div class="algolia__result">
    <a class="algolia__result-link" href="{{ full_url }}#algolia:{{ css_selector }}">{{{ _highlightResult.title.value }}}</a>
    {{#posted_at}}
    <div class="algolia__result-date">{{ posted_at_readable }}</div>
    {{/posted_at}}
    <div class="algolia__result-text">{{{ _highlightResult.text.value }}}</div>
  </div>

</script>
<script id="algolia__template--no-results" type="text/template">
  No results found.
</script>
<script src="//cdn.jsdelivr.net/jquery/2.1.4/jquery.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch/3.6.0/algoliasearch.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch.helper/2.1.0/algoliasearch.helper.min.js"></script>
<script src="//cdn.jsdelivr.net/hogan.js/3.0.2/hogan.min.js"></script>
<script src="//cdn.jsdelivr.net/momentjs/2.10.3/moment.min.js"></script>
<script src="/algoliasearch-jekyll-hyde/public/js/algolia.js"></script>

  </body>
</html>
