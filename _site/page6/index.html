<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Hyde &middot; A Jekyll theme, with instant search
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/algoliasearch-jekyll-hyde/public/css/poole.css">
  <link rel="stylesheet" href="/algoliasearch-jekyll-hyde/public/css/syntax.css">
  <link rel="stylesheet" href="/algoliasearch-jekyll-hyde/public/css/hyde.css">
  <link rel="stylesheet" href="/algoliasearch-jekyll-hyde/public/css/algolia.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/algoliasearch-jekyll-hyde/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/algoliasearch-jekyll-hyde/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-09">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/algoliasearch-jekyll-hyde/">
          Hyde
        </a>
      </h1>
      <p class="lead">The popular <a href="http://hyde.getpoole.com/" target="_blank">Hyde theme</a> for <a href="http://jekyllrb.com" target="_blank">Jekyll</a>, now with instant-search capabilities. Made by <a href="https://twitter.com/mdo" target="_blank">@mdo</a> and <a href="https://www.algolia.com/" target="_blank">Algolia</a></p>
    </div>

    <input type="text" class="algolia__input js-algolia__input" autocomplete="off" name="query" placeholder="Search in this site..." />

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/algoliasearch-jekyll-hyde/">Home</a>

      

      
      
        
          
        
      
        
          
          <a class="sidebar-nav-item" href="/algoliasearch-jekyll-hyde/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="https://github.com/algolia/algoliasearch-jekyll-hyde">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.1.0</span>
    </nav>

    <p>&copy; 2016. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="algolia__initial-content js-algolia__initial-content"><div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/03/25/hipchats-blog-algolia-extends-hipchat-customer-support/">
        On HipChat's blog: Algolia extends HipChat to customer support
      </a>
    </h1>

    <span class="post-date">25 Mar 2014</span>

    <p>As you may probably know, we’re using HipChat to build our live-help chat. If
you want to know more, go ahead and read our <a href="http://blog.hipchat.com/2014/03/25/algolia-extends-hipchat-to-customer-support/">guest post on HipChat’s
blog</a>.</p>

<p><a href="http://blog.hipchat.com/2014/03/25/algolia-extends-hipchat-to-customer-support/"><img src="/algoliasearch-jekyll-hyde/assets/Divided%20screen%20hipchat%20algolia.png" alt="Hipchat: Live help chat." /></a></p>

<p>Algolia uses HipChat to
provide live customer service over chat.</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/03/18/handle-security-realtime-search/">
        Realtime Search: Security and our Javascript Client
      </a>
    </h1>

    <span class="post-date">18 Mar 2014</span>

    <p><em><strong>Edit: As suggested on <a href="https://news.ycombinator.com/item?id=7419205">Hacker
News</a>, SHA256 is not secure, as
it allows a length extension attack. We have replaced it with HMAC-SHA256.</strong></em></p>

<p>Instant is in our DNA, so our first priority was to build a search backend
that would be able to return relevant realtime search results in a few
milliseconds. However, the backend is just one variable in our realtime
equation. The response time perceived by the end user is the total lapse of
time between their first keystroke and the final display of their results.
Thus, with an extremely fast backend, solving this equation comes down to
optimising network latency. This is an issue we solve in two steps:</p>

<ul>
  <li>First, we have <a href="http://blog.algolia.com/added-asian-datacenter-offer/">datacenters in three different locations</a>, allowing us to answer queries in North America, Europe and Asia in less than 100ms (including search computation).</li>
  <li>Second, to keep reducing this perceived latency, queries must be sent directly from the end users’ browsers or mobile phones to our servers. To avoid intermediaries like your own servers, we offer a JavaScript client for websites and ObjC/Android/C# clients for mobile apps.</li>
</ul>

<h2 id="the-security-challenge-of-javascript">The security challenge of JavaScript</h2>

<p>Using this client means that you need to include an API key in your JavaScript
(or mobile app) code. The first security issue with this approach is that this
key can be easily retrieved by anyone who simply looks at the code of the
page. This gives that person the potential to modify the content behind the
website/mobile application! To fix this problem, we provide search-only API
keys which protect your indexes from unauthorized modifications.</p>

<p>This was a first step and we’ve quickly had to solve two other security
issues:</p>

<ul>
  <li>**Limiting the ability to crawl your data: **you may not want people to get all your data by continuous querying. The simple solution was to limit the number of API calls a user could perform in a given period of time. We implemented this by setting a rate limit per IP address. However, this approach is not acceptable if a lot of users are behind a global firewall, thus sharing one IP address. This is very likely for our corporate users.</li>
  <li><strong>Securing access control</strong>:  you may need to restrict the queries of a user to specific content. For example, you may have power users who should get access to more content than “regular” users. The easy way to do it is by using filters. The problem here with simple filters in your JavaScript code is that people can figure out how to modify these filters and get access to content they are not be supposed to see.</li>
</ul>

<h2 id="how-we-solve-it-altogether">How we solve it altogether</h2>

<p>Today, most websites and applications require people to create an account and
log in to access a personalized experience (think of CRM applications,
Facebook or even Netflix). We decided to use these user IDs to solve these two
issues by creating signed API keys. Let’s say you have an API key with search
only permission and want to apply a filter on two groups of content (public OR
power_users_only) for a specific user (id=42):</p>

<pre><code>api_key=20ffce3fdbf036db955d67645bb2c993
query_filters=(public,power_users_only)
user_token=42
</code></pre>

<p>You can generate a secured API key in your backend that is defined by a hash
(HMAC SHA 256) of three elements:</p>

<pre><code>secured_api_key=HMAC_SHA_256(api_key, query_filters + user_token)
secured_api_key=HMAC_SHA_256("20ffce3fdbf036db955d67645bb2c993", "(public,power_users_only)" + "42")
secured_api_key="3abb95c273455ce9b57c61ee5258ba44093f17022dd4bfb39a37e56bee7d24a5"
</code></pre>

<p>For example, if you are using rails, the code in your backend would be:</p>

<pre><code>secured_key = Algolia.generate_secured_api_key('20ffce3fdbf036db955d67645bb2c993', '(public,power_users_only)', '42')
</code></pre>

<p>You can then initialize your JavaScript code with the secured API key and
associated information:</p>

<p>The user identifier (defined by SetUserToken) is used instead of the IP
address for the rate limit and the security filters (defined by
SetSecurityTags) are automatically applied to the query.</p>

<p>In practice, if a user wants to overstep her rights, she will need to modify
her security tags and figure out the new hash. Our backend checks if a query
is legit by computing all the possible hashes using all your available API
keys for the queried index, as well as the security tags defined in the query
and the user identifier (if set).  If there is no match between the hash of
the query and the ones we computed, we will return a permission denied (403).
Don’t worry, reverse-engineering the original API key using brute-force would
require years and <a href="http://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions">thousands of
core</a>.</p>

<p>You may want to apply security filters without limiting the rate of queries,
so if you don’t need both of these features, you can use only one.</p>

<p>We launched this new feature a few weeks ago and we have received very good
feedback so far. Our customers don’t need to choose anymore between security
and realtime search. If you see any way to improve this approach, we would
love to hear your feedback!</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/03/17/caused-todays-performance-issues-europe-will-happen/">
        What Caused Today's Search Performance Issues In Europe and Why It Will Not Happen Again
      </a>
    </h1>

    <span class="post-date">17 Mar 2014</span>

    <p>During a few hours on March 17th you may have noticed longer response times
for some of the queries sent by your users.</p>

<p><img src="/algoliasearch-jekyll-hyde/assets/slowerthanaverage.png" alt="Slower than average search
performance" /></p>

<p><em>Average latency for one of our European clusters on March 17th</em></p>

<p>As you can see above, our slowest average response time (measured from the
user’s browser to our servers and back to the user’s browser) on one of our
European clusters peaked at 858ms. On a normal day, this peak is usually no
higher than 55ms.</p>

<p>This was clearly not a normal behavior for our API, so we investigated.</p>

<h2 id="how-indexing-and-search-calls-share-the-resource">How indexing and search calls share the resource</h2>

<p>Each cluster handles two kinds of calls on our REST API: the ones to build and
modify the indexes (Writes) and the ones to answer users’ queries (Search).
The resources of each cluster are shared between these two uses. As Write
operations are far more expensive than Search calls, we designed our API so
that indexing should never use more than 10% of these resources.</p>

<p>Up until now, we used to set a limitation on the rate of Writes <em>per HTTP
connection</em>. There was no such limit for queries (Search); We simply limited
Write calls to keep search quality. To avoid reaching the Write rate limit too
quickly, we recommended users to Write by batching up to 1GB of operations per
call, rather than sending them one by one. (A batch, for example, could be
adding 1M products to an index on a single network call.) A loophole in this
recommendation was the origin of yesterday’s issues.</p>

<p>What happened yesterday is that on one of our European clusters, one customer
pushed so many unbatched indexing calls from different HTTP connections that
they massively outnumbered the search calls of the other users on the cluster.</p>

<p>This eventually slowed down the average response time for the queries on this
cluster, impacting our usual search performance.</p>

<h2 id="the-solution">The Solution</h2>

<p>As of today, we now set the rate limit of Writes <em>per account</em> and not per
HTTP connection. It prevents anyone from using multiple connections to bypass
this Write rate limit. This also implies that customers who want to push a lot
of operations in a short time simply need to send their calls in batches.</p>

<p>How would you batch your calls? The explanation is in our documentation. See
here for an example with our Ruby client: <a href="https://github.com/algolia
/algoliasearch-client-ruby#batch-writes">https://github.com/algolia
/algoliasearch-client-ruby#batch-writes</a></p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/03/15/algolia-heroku-add-on-enters-ga/">
        Algolia Heroku add-on enters general availability
      </a>
    </h1>

    <span class="post-date">15 Mar 2014</span>

    <p>We launched the first beta of our Heroku add-on in October 2013 and are now
happy to announce its general availability!</p>

<p>During the beta period we received excellent feedback (and some bug reports!)
that helped us improve our integration. We are now fully ready to serve
production on both Heroku datacenters. If you were part of our beta program,
we will contact you shortly to invite you to migrate to a standard plan.</p>

<p>You can directly install it from our <a href="https://addons.heroku.com/algoliasearch">Heroku add-on
page</a> and as ever, please <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#104;&#101;&#121;&#064;&#097;&#108;&#103;&#111;&#108;&#105;&#097;&#046;&#099;&#111;&#109;">let us
know</a> if you have any feedback!</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/algoliasearch-jekyll-hyde/2014/03/14/added-asian-datacenter-offer/">
        Algolia Now Provides Realtime Search in Asia!
      </a>
    </h1>

    <span class="post-date">14 Mar 2014</span>

    <p><a href="http://blog.algolia.com/added-asian-
datacenter-offer/screen-shot-2014-03-13-at-17-51-50/"><img src="/algoliasearch-jekyll-hyde/assets/Screen-Shot-2014-03-13-at-17.51.50-300x199.png" alt="New datacenter allows realtime search in Asia" /></a></p>

<p>One of the terrific advantages of building a SaaS company is that your clients
can be anywhere in the world. We now have customers in more than 15 different
countries distributed across South America, Europe, Africa, and, of course,
North America. We feel incredibly lucky to have so many international
customers trusting us with their search.</p>

<p>Language support is one of the key factors that enabled us to enter these
markets. Since the beginning, we wanted to support every language used on the
Internet. To back our vision with action, we developed a very good support of
Asian languages over time. As an example, we are able to automatically
retrieve results in Traditional Chinese when the query is in Simplified
Chinese (or vice-versa). You simply need to add objects in Chinese, Japanese
or Korean, and we handle the language processing for you.</p>

<p>Despite the fact that we could process Asian languages well, we didn’t plan to
open an Asian datacenter so early, mainly because we thought the API as a
service market was less mature in Asia than in the US or Europe. But we were
surprised when an article on <a href="http://www.36kr.com/p/209747.html">36kr.com</a>
gave us dozen of signups from China. We got more signups from China in the
past month than from Canada!</p>

<p>One of our core values is the speed of our search engine. To provide a
realtime search experience, we want the response times to be lower than 100ms,
including the round trip to search servers. In this context a low latency is
essential. Up to now we have been able to cover North America and Europe in
less than 100ms (search computation included) but our latency with Asia was
between 200ms and 300ms.</p>

<p>The first step of our on-boarding process is to select the datacenter where
your search engine is hosted (we offer multi-datacenter distribution only for
enterprise users). Interestingly, we discovered that we had no drop for
European &amp; US users but it became significant for others. It was a difficult
choice for people outside of these two regions, or even between the two
datacenters. So we also now display the latency from your browser and pre-
select the “closest” datacenter.</p>

<p>To propose better latency and to reduce friction in the on-boarding process,
it was clear that we had to add a datacenter in Asia. We chose Singapore for
its central location. Unfortunately, the hosting market is very different in
Asia. It’s much more expensive to rent servers, so we sadly had to add a
premium on plan prices when choosing this datacenter.</p>

<p>We are very happy to open this new datacenter in Asia with a latency that
reaches our quality standard. Now that Algolia provides realtime search in
Asia, we are even happier to be able to help multinational websites and apps
provide a great search experience to all their users across Europe, North
America &amp; Asia in less than 100ms with our multi-datacenter support!*</p>

<p><em>Multi-datacenter support is currently only available for Enterprise
accounts.</em></p>


  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/algoliasearch-jekyll-hyde/page7">Older</a>
  
  
    
      <a class="pagination-item newer" href="/algoliasearch-jekyll-hyde/page5">Newer</a>
    
  
</div>
</div>

      <div class="algolia__search-content js-algolia__search-content">
        <h1 class="page-title">Search</h1>
        <div class="posts algolia__results"></div>
      </div>
    </div>

  <script>
  window.ALGOLIA_CONFIG = {
    'applicationId': 'latency',
    'indexName': 'jekyll',
    'apiKey': '6be0576ff61c053d5f9a3225e2a90f76',
    'baseurl': '/algoliasearch-jekyll-hyde'
  }
</script>
<script id="algolia__template" type="text/template">

  <div class="algolia__result">
    <a class="algolia__result-link" href="{{ full_url }}#algolia:{{ css_selector }}">{{{ _highlightResult.title.value }}}</a>
    {{#posted_at}}
    <div class="algolia__result-date">{{ posted_at_readable }}</div>
    {{/posted_at}}
    <div class="algolia__result-text">{{{ _highlightResult.text.value }}}</div>
  </div>

</script>
<script id="algolia__template--no-results" type="text/template">
  No results found.
</script>
<script src="//cdn.jsdelivr.net/jquery/2.1.4/jquery.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch/3.6.0/algoliasearch.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch.helper/2.1.0/algoliasearch.helper.min.js"></script>
<script src="//cdn.jsdelivr.net/hogan.js/3.0.2/hogan.min.js"></script>
<script src="//cdn.jsdelivr.net/momentjs/2.10.3/moment.min.js"></script>
<script src="/algoliasearch-jekyll-hyde/public/js/algolia.js"></script>

  </body>
</html>
